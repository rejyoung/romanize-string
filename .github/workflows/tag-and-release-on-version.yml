name: Tag & Release (after Changesets version)

on:
  push:
    branches: [release]
  workflow_dispatch:
    inputs:
      ref:
        description: 'Git ref (branch, tag, or SHA) to run against'
        required: false
      base:
        description: 'Base commit/branch/SHA for diff'
        required: false
      head:
        description: 'Head commit/branch/SHA for diff (defaults to ref/sha)'
        required: false

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  tag_and_release:
    # Run on manual triggers OR on "Version Packages" commits to release
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, 'Version Packages')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write  

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.ref || github.ref }}

      - name: Determine changed packages
        id: pkgs
        env:
          BASE: ${{ inputs.base || github.event.before }}
          HEAD: ${{ inputs.head || github.sha }}
        run: |
          BASE_SHA="${BASE:-}"
          HEAD_SHA="${HEAD:-}"

          # Fallbacks for manual runs if base not provided
          if [ -z "$HEAD_SHA" ]; then
            HEAD_SHA="$(git rev-parse HEAD)"
          fi
          if [ -z "$BASE_SHA" ]; then
            # Default to previous commit on the checked-out ref
            BASE_SHA="$(git rev-parse "${HEAD_SHA}^" || true)"
          fi

          CHANGED=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" \
            | grep -E '^packages/[^/]+/package.json$' || true)

          pkgs=$(echo "$CHANGED" | while read -r f; do
            [ -z "$f" ] && continue
            NAME=$(jq -r '.name' "$f")
            VER=$(jq -r '.version' "$f")
            echo "{\"name\":\"$NAME\",\"version\":\"$VER\",\"path\":\"$f\"}"
          done | jq -c -s '.')
          echo "packages=$pkgs" >> "$GITHUB_OUTPUT"

      - name: Create tags and releases
        uses: actions/github-script@v7
        env:
          PKGS: ${{ steps.pkgs.outputs.packages }}
        with:
          script: |
            const pkgs = JSON.parse(process.env.PKGS || '[]');
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Normalize a branch ref for workflow_dispatch
            const ref = (context.ref || '').replace('refs/heads/', '') || 'release';

            for (const p of pkgs) {
              if (!p.name || !p.version) continue;
              const tag = `${p.name}@${p.version}`;

              // Ensure the tag exists (idempotent)
              try {
                await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
              } catch {
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/tags/${tag}`,
                  sha: context.sha,
                });
              }

              // Create the release if missing
              let createdRelease = false;
              try {
                await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              } catch {
                await github.rest.repos.createRelease({
                  owner, repo,
                  tag_name: tag,
                  name: tag,
                  body: `Automated release created on version bump for \`${p.name}\`.\n\nSee package CHANGELOG for details.`,
                  draft: false,
                  prerelease: false
                });
                createdRelease = true;
              }

              // If and only if we just created the release for thai-engine, kick off build-binaries
              if (createdRelease && p.name === '@romanize-string/thai-engine') {
                await github.rest.actions.createWorkflowDispatch({
                  owner,
                  repo,
                  workflow_id: 'build-binaries.yml',   // file name of the workflow to run
                  ref,                                  // branch to run it on (e.g. "release")
                  inputs: { tag_name: tag }             // pass the tag to build against
                });
              }
            }