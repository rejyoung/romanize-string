name: Tag & Release (after Changesets version)

on:
  push:
    branches: [release]
  workflow_dispatch:
    inputs:
      ref:
        description: 'Git ref (branch, tag, or SHA) to run against'
        required: false
      base:
        description: 'Base commit/branch/SHA for diff'
        required: false
      head:
        description: 'Head commit/branch/SHA for diff (defaults to ref/sha)'
        required: false

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  tag_and_release:
    # Run on manual triggers OR on "Version Packages" commits to release
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, 'Version Packages')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.ref || github.ref }}

      - name: Determine changed packages
        id: pkgs
        env:
          BASE: ${{ inputs.base || github.event.before }}
          HEAD: ${{ inputs.head || github.sha }}
        run: |
          BASE_SHA="${BASE:-}"
          HEAD_SHA="${HEAD:-}"

          # Fallbacks for manual runs if base not provided
          if [ -z "$HEAD_SHA" ]; then
            HEAD_SHA="$(git rev-parse HEAD)"
          fi
          if [ -z "$BASE_SHA" ]; then
            # Default to previous commit on the checked-out ref
            BASE_SHA="$(git rev-parse "${HEAD_SHA}^" || true)"
          fi

          CHANGED=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" \
            | grep -E '^packages/[^/]+/package.json$' || true)

          pkgs=$(echo "$CHANGED" | while read -r f; do
            [ -z "$f" ] && continue
            NAME=$(jq -r '.name' "$f")
            VER=$(jq -r '.version' "$f")
            echo "{\"name\":\"$NAME\",\"version\":\"$VER\",\"path\":\"$f\"}"
          done | jq -c -s '.')
          echo "packages=$pkgs" >> "$GITHUB_OUTPUT"

      - name: Create tags and releases
        uses: actions/github-script@v7
        env:
          PKGS: ${{ steps.pkgs.outputs.packages }}
        with:
          script: |
            const pkgs = JSON.parse(process.env.PKGS || '[]');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            for (const p of pkgs) {
              if (!p.name || !p.version) continue;
              const tag = `${p.name}@${p.version}`;

              // Check if tag already exists
              try {
                await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
                // Tag exists; skip creating it
              } catch (e) {
                // Create lightweight tag pointing to this commit
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/tags/${tag}`,
                  sha: context.sha,
                });
              }

              // Try to create a GitHub Release (idempotent: skip if exists)
              try {
                await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                // Release already exists; skip
              } catch (e) {
                await github.rest.repos.createRelease({
                  owner, repo,
                  tag_name: tag,
                  name: tag,
                  body: `Automated release created on version bump for \`${p.name}\`.\n\nSee package CHANGELOG for details.`,
                  draft: false,
                  prerelease: false
                });
              }
            }